# 20251222233401

## Title
Automatic Programming Pattern (Functional FSM)

## Staging
> **20251222233401**: Let's check whether we factor the project for the use of the automatic programming pattern in the case of sequential processing and changing statuses in the tray icon.

> **20251222233946**: Is this what automatic programming is? ... Is this FSM?

> **20251222234235**: Yes, I would prefer the simpler, non-OOP "Functional FSM" approach.

The goal is to determine if the project uses the "automatic programming pattern" (identified as Automata-Based Programming or Finite State Machine) for handling sequential processing and tray icon updates, and to refactor it if necessary.

## Implementation Details
We refactored the application to use a strict **Functional Finite State Machine (FSM)**.

### State Definitions
Instead of scattered booleans, the app now has a single source of truth:
```python
class State:
    IDLE = "IDLE"          # Waiting for input
    RECORDING = "RECORDING" # Capturing Audio
    PROCESSING = "PROCESSING" # Transcribing Queue
```

### Transition Logic
All state changes go through a single function:
```python
def set_state(new_state):
    # Handles 100% of side effects (Icon color changes, etc.)
    if new_state == State.IDLE: update_icon("blue")
    ...
```

### Reliability
- **Strict Serialization**: The `set_state` bottleneck ensures that the UI (Tray Icon) never lags behind the internal logic.
- **Queue-Driven**: The state automatically stays in `PROCESSING` as long as the content queue is not empty.
- **Non-OOP**: Applied as a functional pattern using global state variables and a transition function, keeping the script lightweight.

## Status
- [x] Implemented in v1.2.2.
- [x] Verified functionality.
